#!/bin/bash
#
# generate-state.sh â€” Auto-generate orchestrator state from filesystem
#
# Scans products/*/ to build an accurate state.yml, eliminating manual drift.
# Run periodically or before orchestrator operations.
#
# Usage: bash .claude/scripts/generate-state.sh
#

set -euo pipefail

REPO_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || echo ".")"
STATE_FILE="$REPO_ROOT/.claude/orchestrator/state.yml"
PORT_REGISTRY="$REPO_ROOT/.claude/PORT-REGISTRY.md"
PRODUCTS_DIR="$REPO_ROOT/products"

if [ ! -d "$PRODUCTS_DIR" ]; then
  echo "ERROR: products/ directory not found at $PRODUCTS_DIR"
  exit 1
fi

# Helper: count TS/TSX files under a directory
count_ts_files() {
  find "$1" \( -name "*.ts" -o -name "*.tsx" \) -not -path "*/node_modules/*" -not -path "*/dist/*" 2>/dev/null | wc -l | tr -d ' '
}

# Helper: detect phase from product contents
detect_phase() {
  local product_dir="$1"
  local ts_count
  ts_count=$(count_ts_files "$product_dir")

  if [ "$ts_count" -eq 0 ]; then
    echo "inception"
    return
  fi

  # Check for docker-compose (production indicator)
  if [ -f "$product_dir/docker-compose.yml" ]; then
    # Check for E2E tests (mature product)
    if [ -d "$product_dir/e2e" ] || [ "$(find "$product_dir" -name "*.spec.ts" -path "*/e2e/*" 2>/dev/null | head -1)" != "" ]; then
      echo "production"
      return
    fi
    echo "development"
    return
  fi

  echo "prototype"
}

# Helper: detect apps (api, web, mobile)
detect_apps() {
  local product_dir="$1"
  local apps=()

  if [ -d "$product_dir/apps/api" ]; then apps+=("api"); fi
  if [ -d "$product_dir/apps/web" ]; then apps+=("web"); fi
  if [ -d "$product_dir/apps/mobile" ]; then apps+=("mobile"); fi

  # Check for extra apps (e.g., merchant-demo)
  if [ -d "$product_dir/apps" ]; then
    for app_dir in "$product_dir/apps"/*/; do
      local app_name
      app_name=$(basename "$app_dir")
      if [[ "$app_name" != "api" && "$app_name" != "web" && "$app_name" != "mobile" ]]; then
        apps+=("$app_name")
      fi
    done
  fi

  echo "${apps[*]:-}"
}

# Helper: extract port from PORT-REGISTRY.md for a product
get_ports() {
  local product="$1"
  local web_port="" api_port="" mobile_port=""

  if [ -f "$PORT_REGISTRY" ]; then
    # Parse frontend port
    web_port=$(grep -E "\|\s*[0-9]+\s*\|\s*$product\s" "$PORT_REGISTRY" | head -1 | awk -F'|' '{print $2}' | tr -d ' ')
    # Parse backend port (appears in Backend APIs section)
    api_port=$(grep -E "\|\s*[0-9]+\s*\|\s*$product\s" "$PORT_REGISTRY" | tail -1 | awk -F'|' '{print $2}' | tr -d ' ')
    # Parse mobile port
    mobile_port=$(grep -E "\|\s*[0-9]+\s*\|\s*$product\s*(mobile)?\s*\|" "$PORT_REGISTRY" | grep -i mobile | awk -F'|' '{print $2}' | tr -d ' ')

    # If web and api are the same, it means only one section matched
    if [ "$web_port" = "$api_port" ]; then
      api_port=""
    fi
  fi

  local port_str="{"
  if [ -n "$web_port" ]; then port_str+=" web: $web_port"; fi
  if [ -n "$api_port" ]; then port_str+=", api: $api_port"; fi
  if [ -n "$mobile_port" ]; then port_str+=", mobile: $mobile_port"; fi
  port_str+=" }"
  echo "$port_str"
}

# Helper: get last commit date for a product
get_last_activity() {
  local product="$1"
  local raw_date
  raw_date=$(git log -1 --format="%ci" -- "products/$product" 2>/dev/null || echo "")
  if [ -n "$raw_date" ]; then
    echo "$raw_date" | awk '{print $1"T"$2"Z"}'
  else
    echo "unknown"
  fi
}

# Start generating state.yml
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

cat > "$STATE_FILE" << HEADER
# ConnectSW Global Orchestrator State
# AUTO-GENERATED by .claude/scripts/generate-state.sh
# Last generated: $TIMESTAMP
# For ground truth on products, scan products/*/ directly.
# To regenerate: bash .claude/scripts/generate-state.sh

company:
  name: "ConnectSW"
  founded: "2025-01-25"
  ceo: "Tamer"

products:
HEADER

# Iterate over each product directory
for product_path in "$PRODUCTS_DIR"/*/; do
  product=$(basename "$product_path")
  ts_count=$(count_ts_files "$product_path")
  phase=$(detect_phase "$product_path")
  apps_list=$(detect_apps "$product_path")
  last_activity=$(get_last_activity "$product")

  # Determine status
  if [ "$ts_count" -eq 0 ] && [ "$phase" = "inception" ]; then
    status="planned"
  else
    status="active"
  fi

  # Format apps as YAML list
  apps_yaml="["
  first=true
  for app in $apps_list; do
    if [ "$first" = true ]; then
      apps_yaml+="$app"
      first=false
    else
      apps_yaml+=", $app"
    fi
  done
  apps_yaml+="]"

  # Get description from README or addendum
  description=""
  if [ -f "$product_path/README.md" ]; then
    description=$(head -5 "$product_path/README.md" | grep -v "^#" | grep -v "^$" | head -1 | sed 's/"/\\"/g' | cut -c1-100)
  elif [ -f "$product_path/.claude/addendum.md" ]; then
    description=$(head -10 "$product_path/.claude/addendum.md" | grep -v "^#" | grep -v "^$" | head -1 | sed 's/"/\\"/g' | cut -c1-100)
  fi

  cat >> "$STATE_FILE" << PRODUCT
  $product:
    path: "products/$product"
    status: "$status"
    phase: "$phase"
    apps: $apps_yaml
    ts_files: $ts_count
    last_activity: "$last_activity"
    notes: "$description"
PRODUCT

done

# Append worktrees
echo "" >> "$STATE_FILE"
echo "# Active worktrees (for parallel product development)" >> "$STATE_FILE"
echo "worktrees:" >> "$STATE_FILE"
worktree_count=0
while IFS= read -r line; do
  # Skip the main worktree (first line) and header
  if [ $worktree_count -gt 0 ]; then
    wt_path=$(echo "$line" | awk '{print $1}')
    wt_branch=$(echo "$line" | awk '{print $2}' | tr -d '[]')
    echo "  $(basename "$wt_path"):" >> "$STATE_FILE"
    echo "    path: \"$wt_path\"" >> "$STATE_FILE"
    echo "    branch: \"$wt_branch\"" >> "$STATE_FILE"
  fi
  worktree_count=$((worktree_count + 1))
done < <(git worktree list 2>/dev/null)

if [ "$worktree_count" -le 1 ]; then
  echo "  # No active worktrees" >> "$STATE_FILE"
fi

# Append footer
cat >> "$STATE_FILE" << FOOTER

# Company-wide pending decisions (cross-product)
pending_decisions: []

# Company-wide checkpoints (cross-product releases, etc.)
checkpoints: []

# Last updated
last_updated: "$TIMESTAMP"
FOOTER

echo "State generated at $STATE_FILE"
echo "Products found: $(ls -d "$PRODUCTS_DIR"/*/ 2>/dev/null | wc -l | tr -d ' ')"
