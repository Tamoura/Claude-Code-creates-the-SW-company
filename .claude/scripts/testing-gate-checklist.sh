#!/bin/bash
# testing-gate-checklist.sh
# Automated testing gate checklist for QA Engineer
# Usage: ./testing-gate-checklist.sh <product>

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

PRODUCT=$1

if [ -z "$PRODUCT" ]; then
  echo "Usage: $0 <product>"
  echo ""
  echo "Example: $0 gpu-calculator"
  exit 1
fi

PRODUCT_DIR="$REPO_ROOT/products/$PRODUCT"

if [ ! -d "$PRODUCT_DIR" ]; then
  echo "Error: Product directory not found: $PRODUCT_DIR"
  exit 1
fi

PASSED=0
FAILED=0
WARNINGS=0

# Helper function for checks
check() {
  local NAME=$1
  local CMD=$2
  local REQUIRED=${3:-true}
  
  printf "Checking: %-50s" "$NAME..."
  
  if eval "$CMD" > /dev/null 2>&1; then
    echo "✅ PASS"
    ((PASSED++))
    return 0
  else
    if [ "$REQUIRED" = "true" ]; then
      echo "❌ FAIL"
      ((FAILED++))
      return 1
    else
      echo "⚠️ WARN"
      ((WARNINGS++))
      return 0
    fi
  fi
}

warn() {
  local NAME=$1
  local MSG=$2
  printf "Warning: %-50s" "$NAME..."
  echo "⚠️ $MSG"
  ((WARNINGS++))
}

echo "╔══════════════════════════════════════════════════════════════╗"
echo "║           TESTING GATE CHECKLIST: $PRODUCT"
echo "║           $(date)"
echo "╚══════════════════════════════════════════════════════════════╝"
echo ""

cd "$PRODUCT_DIR"

# Detect app structure
HAS_WEB=false
HAS_API=false
[ -f "apps/web/package.json" ] && HAS_WEB=true
[ -f "apps/api/package.json" ] && HAS_API=true

# ============================================================================
# PHASE 1: Browser Verification (BLOCKING GATE)
# ============================================================================
echo "┌──────────────────────────────────────────────────────────────┐"
echo "│ Phase 1: Browser Verification (BLOCKING GATE)                │"
echo "└──────────────────────────────────────────────────────────────┘"
echo ""
echo "  Browser verification is the FIRST and HIGHEST-PRIORITY gate."
echo "  If the app doesn't work in a browser, nothing else matters."
echo ""

SMOKE_SCRIPT="$SCRIPT_DIR/smoke-test-gate.sh"
if [ -x "$SMOKE_SCRIPT" ]; then
  if "$SMOKE_SCRIPT" "$PRODUCT" 30; then
    check "Browser smoke test (servers start, health OK, UI loads)" "true"
  else
    echo ""
    echo "╔══════════════════════════════════════════════════════════════╗"
    echo "║  ❌ BROWSER GATE: FAIL — Product does not work in browser   ║"
    echo "║  Remaining phases SKIPPED. Fix browser issues first.        ║"
    echo "╚══════════════════════════════════════════════════════════════╝"
    echo ""

    # Still generate a report for diagnosis
    REPORT_DIR="$PRODUCT_DIR/docs/quality-reports"
    mkdir -p "$REPORT_DIR"
    REPORT_FILE="$REPORT_DIR/testing-gate-$(date +%Y%m%d-%H%M%S).md"
    cat > "$REPORT_FILE" << EOF
# Testing Gate Report

**Product**: $PRODUCT
**Date**: $(date)
**Status**: FAIL

## Results

- Phase 1 (Browser Verification): FAIL
- Phases 2-6: SKIPPED (browser gate is blocking)

## Details

The product does not work in the browser. All subsequent phases
(prerequisites, unit tests, E2E, code quality, coverage) were
skipped because browser verification is the highest-priority gate.

Fix the browser issues and run again.

---

*Generated by testing-gate-checklist.sh*
EOF

    echo "Report saved: $REPORT_FILE"
    echo "GATE_REPORT_FILE=$REPORT_FILE"

    # Record gate result in metrics
    if [ -f "$SCRIPT_DIR/update-gate-metrics.sh" ]; then
      DETAILS="{\"passed\":0,\"failed\":1,\"warnings\":0,\"product\":\"$PRODUCT\",\"blocking_phase\":\"browser-verification\"}"
      bash "$SCRIPT_DIR/update-gate-metrics.sh" "testing" "$PRODUCT" "fail" "$DETAILS" 2>/dev/null || true
    fi

    exit 1
  fi
else
  echo "  ⚠️  smoke-test-gate.sh not found or not executable."
  echo "  Skipping browser gate (add smoke-test-gate.sh to enforce)."
  ((WARNINGS++))
fi

echo ""

# ============================================================================
# PHASE 2: Prerequisites
# ============================================================================
echo "┌──────────────────────────────────────────────────────────────┐"
echo "│ Phase 2: Prerequisites                                       │"
echo "└──────────────────────────────────────────────────────────────┘"

check "Package.json exists" "test -f package.json"

if [ "$HAS_API" = true ]; then
  check "API node_modules" "test -d apps/api/node_modules || (cd apps/api && npm install)"
  check "API TypeScript compiles" "cd apps/api && (npm run build 2>/dev/null || npx tsc --noEmit 2>/dev/null || true)" false
fi

if [ "$HAS_WEB" = true ]; then
  check "Web node_modules" "test -d apps/web/node_modules || (cd apps/web && npm install)"
  check "Web TypeScript compiles" "cd apps/web && (npm run build 2>/dev/null || npx tsc --noEmit 2>/dev/null || true)" false
fi

if [ "$HAS_WEB" = false ] && [ "$HAS_API" = false ]; then
  check "Node modules installed" "test -d node_modules || npm install"
  check "TypeScript compiles" "npm run build 2>/dev/null || npx tsc --noEmit 2>/dev/null || true" false
fi

echo ""

# ============================================================================
# PHASE 3: Unit Tests
# ============================================================================
echo "┌──────────────────────────────────────────────────────────────┐"
echo "│ Phase 3: Unit Tests                                          │"
echo "└──────────────────────────────────────────────────────────────┘"

# API tests
if [ "$HAS_API" = true ]; then
  cd "$PRODUCT_DIR/apps/api"
  if npm test > /dev/null 2>&1; then
    check "API tests pass" "npm test"
  else
    warn "API tests" "npm test failed or not configured"
  fi
  cd "$PRODUCT_DIR"
fi

# Web tests
if [ "$HAS_WEB" = true ]; then
  cd "$PRODUCT_DIR/apps/web"
  if npm run test:run > /dev/null 2>&1; then
    check "Web unit tests pass" "npm run test:run"
  elif npm run test -- --run > /dev/null 2>&1; then
    check "Web unit tests pass" "npm run test -- --run"
  elif npm test > /dev/null 2>&1; then
    check "Web unit tests pass" "npm test -- --passWithNoTests"
  else
    warn "Web unit tests" "No test command found"
  fi
  cd "$PRODUCT_DIR"
fi

# Fallback: root-level tests
if [ "$HAS_WEB" = false ] && [ "$HAS_API" = false ]; then
  if npm run test:run > /dev/null 2>&1; then
    check "Unit tests pass" "npm run test:run"
  elif npm test > /dev/null 2>&1; then
    check "Unit tests pass" "npm test -- --passWithNoTests"
  else
    warn "Unit tests" "No test command found"
  fi
fi

echo ""

# ============================================================================
# PHASE 4: E2E Tests (MANDATORY — every product must have E2E tests)
# ============================================================================
echo "┌──────────────────────────────────────────────────────────────┐"
echo "│ Phase 4: E2E Tests (MANDATORY)                               │"
echo "└──────────────────────────────────────────────────────────────┘"

# Search for E2E tests in multiple locations
E2E_DIR=""
for candidate in "apps/web/e2e" "e2e" "apps/web/tests/e2e"; do
  if [ -d "$candidate" ]; then
    E2E_DIR="$candidate"
    break
  fi
done

if [ -n "$E2E_DIR" ]; then
  E2E_FILE_COUNT=$(find "$E2E_DIR" -name "*.spec.ts" -o -name "*.spec.js" -o -name "*.test.ts" -o -name "*.test.js" 2>/dev/null | wc -l | tr -d ' ')
  check "E2E test directory exists ($E2E_DIR)" "test -d $E2E_DIR"

  if [ "$E2E_FILE_COUNT" -lt 3 ]; then
    printf "Checking: %-50s" "Minimum E2E test files (>= 3)..."
    echo "❌ FAIL (found $E2E_FILE_COUNT)"
    ((FAILED++))
  else
    printf "Checking: %-50s" "Minimum E2E test files (>= 3)..."
    echo "✅ PASS ($E2E_FILE_COUNT files)"
    ((PASSED++))
  fi

  # Run E2E tests — REQUIRED, not optional
  if [ "$HAS_WEB" = true ]; then
    cd "$PRODUCT_DIR/apps/web"
    check "E2E tests pass" "npx playwright test 2>/dev/null || npm run test:e2e 2>/dev/null"
    cd "$PRODUCT_DIR"
  else
    check "E2E tests pass" "npm run test:e2e 2>/dev/null || npx playwright test 2>/dev/null"
  fi
else
  printf "Checking: %-50s" "E2E test directory exists..."
  echo "❌ FAIL (no e2e/ directory found)"
  ((FAILED++))
  echo "  Every product must have Playwright E2E tests."
  echo "  Create an e2e/ directory with .spec.ts files."
fi

echo ""

# ============================================================================
# PHASE 5: Code Quality
# ============================================================================
echo "┌──────────────────────────────────────────────────────────────┐"
echo "│ Phase 5: Code Quality                                        │"
echo "└──────────────────────────────────────────────────────────────┘"

check "Linting passes" "npm run lint 2>/dev/null || npx eslint . 2>/dev/null || true" false
check "No console.error in production" "! grep -r 'console.error' apps/*/src --include='*.ts' --include='*.tsx' 2>/dev/null | grep -v test | grep -v '.d.ts' | head -1" false
check "No TODO/FIXME in production" "! grep -r 'TODO\|FIXME' apps/*/src --include='*.ts' --include='*.tsx' 2>/dev/null | head -1" false

echo ""

# ============================================================================
# PHASE 6: Coverage
# ============================================================================
echo "┌──────────────────────────────────────────────────────────────┐"
echo "│ Phase 6: Test Coverage                                       │"
echo "└──────────────────────────────────────────────────────────────┘"

# Measure coverage per-app for monorepo products, then aggregate
COVERAGE_RESULTS=""
COVERAGE_PASS=true

run_coverage_for_app() {
  local app_dir="$1"
  local app_name="$2"
  cd "$app_dir"
  if npm run test -- --coverage --passWithNoTests > /tmp/coverage-${app_name}.txt 2>&1; then
    local cov=$(grep -E "All files|Statements" /tmp/coverage-${app_name}.txt | grep -oE "[0-9]+\.[0-9]+" | head -1 || echo "0")
    if [ -n "$cov" ] && [ "$cov" != "0" ]; then
      local cov_int=${cov%.*}
      COVERAGE_RESULTS="$COVERAGE_RESULTS ${app_name}:${cov}%"
      if [ "$cov_int" -lt 80 ]; then
        COVERAGE_PASS=false
      fi
      echo "  ${app_name}: ${cov}%"
    fi
  fi
  cd "$PRODUCT_DIR"
}

if [ "$HAS_API" = true ] || [ "$HAS_WEB" = true ]; then
  echo "  Measuring coverage per app..."
  [ "$HAS_API" = true ] && run_coverage_for_app "$PRODUCT_DIR/apps/api" "api"
  [ "$HAS_WEB" = true ] && run_coverage_for_app "$PRODUCT_DIR/apps/web" "web"

  if [ -n "$COVERAGE_RESULTS" ]; then
    if [ "$COVERAGE_PASS" = true ]; then
      printf "Checking: %-50s" "Coverage >= 80% (all apps)..."
      echo "✅ PASS ($COVERAGE_RESULTS)"
      ((PASSED++))
    else
      printf "Checking: %-50s" "Coverage >= 80% (all apps)..."
      echo "❌ FAIL ($COVERAGE_RESULTS)"
      ((FAILED++))
    fi
  else
    warn "Coverage" "Could not parse coverage from any app"
  fi
else
  # Non-monorepo: run from product root
  if npm run test -- --coverage > /tmp/coverage.txt 2>&1; then
    COVERAGE=$(grep -E "All files|Statements" /tmp/coverage.txt | grep -oE "[0-9]+\.[0-9]+" | head -1 || echo "0")
    if [ -n "$COVERAGE" ]; then
      COVERAGE_INT=${COVERAGE%.*}
      if [ "$COVERAGE_INT" -ge 80 ]; then
        printf "Checking: %-50s" "Coverage >= 80%..."
        echo "✅ PASS ($COVERAGE%)"
        ((PASSED++))
      else
        printf "Checking: %-50s" "Coverage >= 80%..."
        echo "❌ FAIL ($COVERAGE%)"
        ((FAILED++))
      fi
    else
      warn "Coverage" "Could not parse coverage"
    fi
  else
    warn "Coverage" "Could not run coverage report"
  fi
fi

echo ""

# ============================================================================
# RESULTS
# ============================================================================
echo "╔══════════════════════════════════════════════════════════════╗"
echo "║                         RESULTS                              ║"
echo "╚══════════════════════════════════════════════════════════════╝"
echo ""
echo "  ✅ Passed:   $PASSED"
echo "  ❌ Failed:   $FAILED"
echo "  ⚠️  Warnings: $WARNINGS"
echo ""

# Generate report
REPORT_DIR="$PRODUCT_DIR/docs/quality-reports"
mkdir -p "$REPORT_DIR"
REPORT_FILE="$REPORT_DIR/testing-gate-$(date +%Y%m%d-%H%M%S).md"

cat > "$REPORT_FILE" << EOF
# Testing Gate Report

**Product**: $PRODUCT
**Date**: $(date)
**Status**: $([ $FAILED -eq 0 ] && echo "PASS" || echo "FAIL")

## Results

- Passed: $PASSED
- Failed: $FAILED
- Warnings: $WARNINGS

## Checklist

$([ $FAILED -eq 0 ] && echo "All required checks passed." || echo "Some checks failed - see above output.")

---

*Generated by testing-gate-checklist.sh*
EOF

echo "Report saved: $REPORT_FILE"
echo ""

# Record gate result in metrics
if [ -f "$SCRIPT_DIR/update-gate-metrics.sh" ]; then
  RESULT=$([ $FAILED -gt 0 ] && echo "fail" || echo "pass")
  DETAILS="{\"passed\":$PASSED,\"failed\":$FAILED,\"warnings\":$WARNINGS,\"product\":\"$PRODUCT\"}"
  bash "$SCRIPT_DIR/update-gate-metrics.sh" "testing" "$PRODUCT" "$RESULT" "$DETAILS" 2>/dev/null || true
fi

echo "GATE_REPORT_FILE=$REPORT_FILE"

if [ $FAILED -gt 0 ]; then
  echo "╔══════════════════════════════════════════════════════════════╗"
  echo "║              ❌ TESTING GATE: FAIL                           ║"
  echo "╚══════════════════════════════════════════════════════════════╝"
  echo ""
  echo "Fix the failing checks and run again."
  exit 1
else
  echo "╔══════════════════════════════════════════════════════════════╗"
  echo "║              ✅ TESTING GATE: PASS                           ║"
  echo "╚══════════════════════════════════════════════════════════════╝"
  echo ""
  echo "Ready for CEO checkpoint."
  exit 0
fi
