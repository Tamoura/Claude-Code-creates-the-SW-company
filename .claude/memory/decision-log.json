{
  "version": "2.0.0",
  "updated_at": "2026-02-18T10:00:00Z",
  "decisions": [
    {
      "id": "CONST-001",
      "date": "2026-01-25",
      "category": "constitutional",
      "title": "Spec-First Development as Article I",
      "decision": "No code can be written without an approved specification. Specs must include user stories, acceptance criteria, and business context.",
      "rationale": "Prevents wasted development effort on the wrong feature. Discovered early that agents were implementing assumptions rather than requirements.",
      "alternatives_considered": ["Lightweight PRD only", "Code-first with retrospective docs"],
      "outcome": "All products have richer specs. Rework rate dropped significantly.",
      "applies_to": "all-products"
    },
    {
      "id": "CONST-002",
      "date": "2026-01-25",
      "category": "constitutional",
      "title": "Component Reuse Before Creation as Article II",
      "decision": "Before building any component, agents must check the COMPONENT-REGISTRY.md. If a matching component exists, copy and adapt it.",
      "rationale": "Prevented rebuilding the same auth plugin 4 times across 4 products. Registry now has 60+ production-tested components.",
      "alternatives_considered": ["Per-product libraries with no sharing", "NPM private registry"],
      "outcome": "Significant time savings. Auth, webhook, billing patterns reused across all products.",
      "applies_to": "all-products"
    },
    {
      "id": "CONST-003",
      "date": "2026-01-25",
      "category": "constitutional",
      "title": "TDD with No Mocks as Article III",
      "decision": "Tests must be written before implementation. Integration tests use real databases and services — no mocks.",
      "rationale": "Mocked tests pass but the real system fails. Real DB integration catches schema mismatches, query errors, and concurrency issues that mocks hide.",
      "alternatives_considered": ["Mock-based unit tests only", "E2E-only testing"],
      "outcome": "Higher test coverage with more confidence. Real bugs caught before production.",
      "applies_to": "all-products"
    },
    {
      "id": "CONST-004",
      "date": "2026-01-25",
      "category": "constitutional",
      "title": "TypeScript Strict Mode as Article IV",
      "decision": "All JavaScript code must be TypeScript with strict mode enabled. Zod for runtime validation at API boundaries.",
      "rationale": "Prevents entire class of runtime errors. Type inference across Prisma, Fastify, and React catches mismatches at compile time.",
      "alternatives_considered": ["TypeScript without strict", "JavaScript with JSDoc"],
      "outcome": "Zero type-related production bugs across all products.",
      "applies_to": "all-products"
    },
    {
      "id": "CONST-005",
      "date": "2026-01-25",
      "category": "constitutional",
      "title": "Default Technology Stack as Article V",
      "decision": "Default stack: Fastify + Prisma + PostgreSQL for backend; Next.js 14+ for SSR frontend; Vite for client-only frontends; Tailwind CSS for styling.",
      "rationale": "Consistency enables agent knowledge reuse. Same stack patterns apply across all products — faster onboarding, shared tooling.",
      "alternatives_considered": ["Express.js", "Drizzle ORM", "React without Next.js"],
      "outcome": "Strong consistency across 8+ products. Shared packages (auth, webhooks, billing) possible because of consistent stack.",
      "applies_to": "all-products"
    },
    {
      "id": "CONST-006",
      "date": "2026-01-25",
      "category": "constitutional",
      "title": "Specification Traceability as Article VI",
      "decision": "Every task must trace to a spec requirement. Commit messages for feat/fix/test must include [US-XX], [FR-XXX], or #issue.",
      "rationale": "Without traceability, scope creep is invisible and spec coverage cannot be verified. Commit-msg hook enforces this.",
      "alternatives_considered": ["Optional traceability", "Only at PR level"],
      "outcome": "Full traceability from spec to commit. Commit-msg hook in .githooks/ enforces hard.",
      "applies_to": "all-products"
    },
    {
      "id": "CONST-007",
      "date": "2026-01-25",
      "category": "constitutional",
      "title": "Port Registry Compliance as Article VII",
      "decision": "All products must register ports in .claude/PORT-REGISTRY.md before use. Frontend: 3100-3199, Backend: 5000-5099, Mobile: 8081-8099.",
      "rationale": "Port conflicts prevent running multiple products simultaneously. Registry prevents accidental reuse.",
      "alternatives_considered": ["Random ports per product", "Docker-managed ports only"],
      "outcome": "All products run simultaneously without port conflicts.",
      "applies_to": "all-products"
    },
    {
      "id": "CONST-008",
      "date": "2026-01-25",
      "category": "constitutional",
      "title": "Git Safety as Article VIII",
      "decision": "Never use git add . or git add -A. Always stage specific files. Pre-commit hook blocks >30 files or >5000 deleted lines.",
      "rationale": "A bad branch base once deleted 600+ files. Specific staging prevents accidental mass deletion from branch divergence.",
      "alternatives_considered": ["No restrictions on staging", "Soft warnings only"],
      "outcome": "Zero mass-delete incidents since enforcement. Pre-commit hook in .githooks/ is source-controlled.",
      "applies_to": "all-products"
    },
    {
      "id": "CONST-009",
      "date": "2026-02-12",
      "category": "constitutional",
      "title": "Quality Gates System as Article IX",
      "decision": "Six quality gates: Spec Consistency (-1), Browser-First (0), Security (1), Performance (2), Testing (3), Production Readiness (4). All must pass before CEO checkpoint.",
      "rationale": "Issues discovered late are exponentially more expensive. Gates catch issues at earliest, cheapest stage.",
      "alternatives_considered": ["Single QA gate before release", "Continuous testing only"],
      "outcome": "Multi-gate system documented in .claude/quality-gates/multi-gate-system.md.",
      "applies_to": "all-products"
    },
    {
      "id": "CONST-010",
      "date": "2026-02-18",
      "category": "constitutional",
      "title": "Diagram-First Documentation as Article X",
      "decision": "If something can be explained with a diagram, it must include a Mermaid diagram. Text supplements diagrams. C4, sequence, ER, flowchart diagrams required by doc type.",
      "rationale": "Walls of text are skipped. Diagrams communicate structure and flow in seconds. Constitution Article IX codifies this for all future documentation.",
      "alternatives_considered": ["Optional diagrams", "External diagramming tools"],
      "outcome": "Mermaid renders natively in GitHub and Command Center. All new docs must include relevant diagrams.",
      "applies_to": "all-products"
    },
    {
      "id": "SG-ADR-001",
      "date": "2026-01-28",
      "category": "product-architecture",
      "product": "stablecoin-gateway",
      "title": "Prototype Tech Stack: Vite + React (no backend)",
      "decision": "Two-hour validation prototype uses Vite + React with mocked blockchain interactions. No backend for prototype.",
      "rationale": "Validate merchant UX before investing in backend. Speed of validation > technical completeness.",
      "alternatives_considered": ["Full-stack prototype", "Static HTML mockup"],
      "outcome": "Prototype validated demand. Full Fastify + PostgreSQL backend built in next phase.",
      "applies_to": "stablecoin-gateway"
    },
    {
      "id": "SG-ADR-002",
      "date": "2026-01-30",
      "category": "product-architecture",
      "product": "stablecoin-gateway",
      "title": "Blockchain Integration: API-based not on-chain",
      "decision": "Integrate with blockchain via Circle API and Alchemy for USDC/USDT — not direct node operation.",
      "rationale": "Operating blockchain nodes requires significant infrastructure and expertise. Circle API provides enterprise-grade reliability. Faster time to market.",
      "alternatives_considered": ["Self-operated Ethereum nodes", "Ethers.js direct integration"],
      "outcome": "Integration completed in days not months. Circle API handles compliance requirements.",
      "applies_to": "stablecoin-gateway"
    },
    {
      "id": "SG-ADR-003",
      "date": "2026-01-30",
      "category": "product-architecture",
      "product": "stablecoin-gateway",
      "title": "Backend Architecture: Fastify with Plugin System",
      "decision": "Use Fastify with modular plugin architecture. Auth, rate limiting, webhooks each as separate plugins. Prisma for ORM.",
      "rationale": "Plugin system enables clean separation. Production-ready out of box with excellent TypeScript support. 2x faster than Express in benchmarks.",
      "alternatives_considered": ["Express.js", "Nest.js", "Hono"],
      "outcome": "Plugin architecture enabled full reuse in subsequent products. Auth plugin now in packages/auth.",
      "applies_to": "stablecoin-gateway"
    },
    {
      "id": "SG-ADR-004",
      "date": "2026-02-02",
      "category": "product-architecture",
      "product": "stablecoin-gateway",
      "title": "Wallet Integration: Multi-Signature Custody",
      "decision": "Use multi-signature wallet custody with hardware security module (HSM) simulation in dev. Separate hot/cold wallet architecture.",
      "rationale": "Institutional customers require custody controls. Single-key wallets are unacceptable security posture for payment gateway.",
      "alternatives_considered": ["Single-key managed wallet", "Full on-chain custody"],
      "outcome": "Institutional-grade security model documented. HSM integration path defined.",
      "applies_to": "stablecoin-gateway"
    },
    {
      "id": "AF-ADR-001",
      "date": "2026-02-19",
      "category": "product-architecture",
      "product": "archforge",
      "title": "AI Service Architecture: Async Queue-Based Generation",
      "decision": "Use async queue-based processing (BullMQ + Redis) for LLM artifact generation. SSE for real-time progress updates to client.",
      "rationale": "Artifact generation takes 15-30 seconds — too long for synchronous HTTP. Queue enables retry, priority, and backpressure. SSE avoids WebSocket complexity for one-directional updates.",
      "alternatives_considered": ["Synchronous LLM calls", "WebSockets for streaming", "Polling"],
      "outcome": "Robust generation pipeline with retry and progress visibility.",
      "applies_to": "archforge"
    },
    {
      "id": "AF-ADR-002",
      "date": "2026-02-19",
      "category": "product-architecture",
      "product": "archforge",
      "title": "Canvas Technology: React Flow",
      "decision": "Use React Flow for the interactive architecture canvas. Custom node types for ArchiMate and C4 elements.",
      "rationale": "React Flow is the most mature open-source graph visualization library for React. Custom node system supports ArchiMate/C4 notation. Active community and good TypeScript support.",
      "alternatives_considered": ["D3.js custom canvas", "mxGraph/draw.io embedded", "Konva.js"],
      "outcome": "Canvas prototype functional with custom ArchiMate node types.",
      "applies_to": "archforge"
    },
    {
      "id": "AF-ADR-003",
      "date": "2026-02-19",
      "category": "product-architecture",
      "product": "archforge",
      "title": "Real-Time Collaboration: Yjs CRDTs",
      "decision": "Use Yjs CRDT library for real-time collaborative editing of architecture diagrams. y-websocket for transport.",
      "rationale": "CRDTs handle concurrent edits without conflicts — critical for collaborative diagramming. Yjs is the leading CRDT library for JavaScript with excellent React Flow integration.",
      "alternatives_considered": ["Operational Transform (ShareDB)", "Lock-based editing", "No collaboration in v1"],
      "outcome": "Conflict-free collaborative editing architecture defined.",
      "applies_to": "archforge"
    },
    {
      "id": "AF-ADR-004",
      "date": "2026-02-19",
      "category": "product-architecture",
      "product": "archforge",
      "title": "Export Pipeline: Server-Side PDF/PNG Generation",
      "decision": "Generate diagram exports (PDF, PNG, SVG) server-side using Puppeteer. Client sends diagram state JSON; server renders to headless browser and returns binary.",
      "rationale": "Client-side canvas-to-PNG has quality limitations. Server-side Puppeteer produces pixel-perfect output. Also enables scheduled/automated exports.",
      "alternatives_considered": ["html2canvas client-side", "jsPDF client-side", "SVG export only"],
      "outcome": "High-quality export pipeline using server-side rendering.",
      "applies_to": "archforge"
    },
    {
      "id": "CG-ADR-001",
      "date": "2026-02-19",
      "category": "product-architecture",
      "product": "codeguardian",
      "title": "Multi-Model Routing Strategy",
      "decision": "Route code review requests across multiple LLMs (Claude for reasoning, GPT-4 for code, DeepSeek for cost optimization) based on task type and cost budget.",
      "rationale": "No single model is best at all review tasks. Claude excels at architectural reasoning; GPT-4 at code generation suggestions; DeepSeek at lower cost for bulk analysis.",
      "alternatives_considered": ["Single model (Claude only)", "Manual model selection", "Model ensemble always"],
      "outcome": "Intelligent routing reduces cost by 40% while maintaining quality on complex reviews.",
      "applies_to": "codeguardian"
    },
    {
      "id": "CG-ADR-002",
      "date": "2026-02-19",
      "category": "product-architecture",
      "product": "codeguardian",
      "title": "Async Review Pipeline with BullMQ",
      "decision": "Code review jobs submitted to BullMQ queue. Workers process asynchronously. GitHub PR comment posted when complete.",
      "rationale": "Large PRs can take 30-120 seconds to review. Synchronous processing would block and timeout. Queue enables retry, priority by repo tier, and worker scaling.",
      "alternatives_considered": ["Synchronous review on PR event", "Serverless functions per PR"],
      "outcome": "Reliable async pipeline with retry and SLA tracking per queue priority.",
      "applies_to": "codeguardian"
    },
    {
      "id": "CG-ADR-003",
      "date": "2026-02-19",
      "category": "product-architecture",
      "product": "codeguardian",
      "title": "GitHub Integration: GitHub App (not OAuth)",
      "decision": "Use GitHub App installation model for repository access. Not OAuth personal access tokens.",
      "rationale": "GitHub Apps provide per-repository permissions, installation-level tokens, and better security model for enterprise. OAuth PATs expire and are user-scoped.",
      "alternatives_considered": ["GitHub OAuth App", "Personal Access Token per user"],
      "outcome": "Enterprise-grade GitHub integration with fine-grained permissions.",
      "applies_to": "codeguardian"
    },
    {
      "id": "CG-ADR-004",
      "date": "2026-02-19",
      "category": "product-architecture",
      "product": "codeguardian",
      "title": "Scoring Algorithm: Weighted Multi-Dimension Score",
      "decision": "Code quality score = weighted average of: Security (30%), Correctness (25%), Performance (20%), Maintainability (15%), Style (10%). Score 0-100.",
      "rationale": "Security issues are most critical and should dominate the score. Weighted scoring allows dashboard trends over time. Simple enough for developers to understand.",
      "alternatives_considered": ["Binary pass/fail", "Separate unweighted scores per dimension", "AI-generated narrative only"],
      "outcome": "Scoring algorithm documented and implemented in analysis service.",
      "applies_to": "codeguardian"
    },
    {
      "id": "HID-ADR-001",
      "date": "2026-02-18",
      "category": "product-architecture",
      "product": "humanid",
      "title": "DID Method: did:ion on Bitcoin",
      "decision": "Use did:ion (ION network, anchored on Bitcoin) as the primary DID method for HumanID identifiers.",
      "rationale": "Bitcoin provides strongest security guarantees. ION is a Layer 2 DID network with no transaction fees, permissionless operation, and W3C DID compliance. Sidetree protocol scales to millions of DIDs.",
      "alternatives_considered": ["did:ethr on Ethereum", "did:web (centralized)", "did:key (no blockchain)"],
      "outcome": "ION integration defined. DID resolution SDK selected.",
      "applies_to": "humanid"
    },
    {
      "id": "HID-ADR-002",
      "date": "2026-02-18",
      "category": "product-architecture",
      "product": "humanid",
      "title": "ZKP Framework: Circom + snarkjs",
      "decision": "Use Circom for ZK circuit authoring and snarkjs for proof generation and verification in browser/Node.js.",
      "rationale": "Circom is the most widely adopted ZK circuit language. snarkjs enables client-side proof generation (no sensitive data leaves device). Groth16 proofs are small and fast to verify.",
      "alternatives_considered": ["ZoKrates", "Noir (Aztec)", "Halo2"],
      "outcome": "ZKP circuits defined for age attestation and credential disclosure.",
      "applies_to": "humanid"
    },
    {
      "id": "HID-ADR-003",
      "date": "2026-02-18",
      "category": "product-architecture",
      "product": "humanid",
      "title": "Blockchain Network: Bitcoin (ION) + Ethereum (VC anchoring)",
      "decision": "Bitcoin ION for DID anchoring. Ethereum mainnet for Verifiable Credential revocation registry (EIP-5539 revocation list).",
      "rationale": "Two-chain approach: Bitcoin for DID security (most battle-tested), Ethereum for smart contract programmability needed for revocation registries.",
      "alternatives_considered": ["Single chain (Ethereum only)", "Polygon for lower fees", "No on-chain revocation"],
      "outcome": "Dual-chain architecture with clear responsibility separation.",
      "applies_to": "humanid"
    },
    {
      "id": "HID-ADR-004",
      "date": "2026-02-18",
      "category": "product-architecture",
      "product": "humanid",
      "title": "Credential Format: W3C VC Data Model 2.0",
      "decision": "Use W3C Verifiable Credentials Data Model 2.0 with JSON-LD context. BBS+ signatures for selective disclosure.",
      "rationale": "W3C VC 2.0 is the emerging standard with broadest interoperability. BBS+ signatures enable selective disclosure without additional ZKP circuits for simple attribute reveals.",
      "alternatives_considered": ["JWT-based VCs (W3C VC 1.0)", "AnonCreds (Hyperledger)", "SD-JWT"],
      "outcome": "W3C compliant credentials with selective disclosure capability.",
      "applies_to": "humanid"
    },
    {
      "id": "HID-ADR-005",
      "date": "2026-02-18",
      "category": "product-architecture",
      "product": "humanid",
      "title": "Key Management: PBKDF2 + HSM Delegation",
      "decision": "User keys derived from password + salt via PBKDF2 (600,000 iterations). Private keys never leave device. HSM for institutional issuer keys.",
      "rationale": "Self-sovereign identity requires user-controlled keys. PBKDF2 standard prevents brute force. HSM for issuers provides enterprise-grade key custody.",
      "alternatives_considered": ["Custodial key management", "Hardware wallet only", "Cloud KMS for all keys"],
      "outcome": "Non-custodial key architecture with enterprise issuer path.",
      "applies_to": "humanid"
    },
    {
      "id": "QDB-ADR-001",
      "date": "2026-02-14",
      "category": "product-architecture",
      "product": "qdb-one",
      "title": "Identity Resolution: Universal Identity Layer",
      "decision": "Build a universal identity resolution layer supporting LDAP, OAuth2, SAML, and custom identity providers. Unified identity token issued after resolution.",
      "rationale": "Enterprise customers have existing identity infrastructure. qdb-one must integrate, not replace. Universal layer abstracts provider differences.",
      "alternatives_considered": ["Single IdP support only", "Bring-your-own-JWT", "Auth0 dependency"],
      "outcome": "Multi-protocol identity resolution architecture defined.",
      "applies_to": "qdb-one"
    },
    {
      "id": "QDB-ADR-002",
      "date": "2026-02-14",
      "category": "product-architecture",
      "product": "qdb-one",
      "title": "Authentication: FIDO2/WebAuthn Passwordless",
      "decision": "Primary authentication via FIDO2/WebAuthn (passkeys). Password fallback for legacy contexts only.",
      "rationale": "Enterprise security standards increasingly require phishing-resistant authentication. WebAuthn is W3C standard with broad browser support. Passkeys eliminate password reuse risk.",
      "alternatives_considered": ["Password + TOTP MFA", "Hardware tokens only", "Certificate-based auth"],
      "outcome": "Passwordless-first auth with hardware security key support.",
      "applies_to": "qdb-one"
    },
    {
      "id": "QDB-ADR-003",
      "date": "2026-02-14",
      "category": "product-architecture",
      "product": "qdb-one",
      "title": "Data Access: CQRS with GraphQL Federation",
      "decision": "CQRS pattern with separate command and query services. GraphQL Federation for unified API layer across multiple backend services.",
      "rationale": "Enterprise data platforms have complex read/write asymmetry. CQRS scales reads independently. GraphQL Federation enables microservice autonomy with unified client API.",
      "alternatives_considered": ["REST CRUD API", "Single GraphQL monolith", "gRPC"],
      "outcome": "Scalable data access layer with separate optimization for reads vs writes.",
      "applies_to": "qdb-one"
    },
    {
      "id": "QDB-ADR-009",
      "date": "2026-02-14",
      "category": "product-architecture",
      "product": "qdb-one",
      "title": "Deployment: On-Premise Kubernetes",
      "decision": "qdb-one deploys on customer-managed Kubernetes clusters. Helm charts provided. Air-gap installation supported.",
      "rationale": "Enterprise data platforms handle sensitive internal data. Most enterprise customers cannot use SaaS due to data residency requirements. On-premise deployment is table stakes.",
      "alternatives_considered": ["SaaS-only", "Managed cloud (AWS/Azure marketplace)", "Docker Compose for small installs"],
      "outcome": "Kubernetes-first deployment with Helm charts and air-gap installation guide.",
      "applies_to": "qdb-one"
    },
    {
      "id": "QCU-ADR-001",
      "date": "2026-02-08",
      "category": "product-architecture",
      "product": "quantum-computing-usecases",
      "title": "Prototype Tech Stack: Vite + React (frontend only)",
      "decision": "Quantum Computing Use Cases is a frontend-only interactive explorer. Vite + React. No backend required.",
      "rationale": "Product is educational content with interactive simulations. All content is static or client-computed. No user data to store. No backend adds unnecessary complexity.",
      "alternatives_considered": ["Next.js with SSR", "Static site generator", "Full-stack with API"],
      "outcome": "Lightweight Vite app deployed as static site. Fast iteration on content.",
      "applies_to": "quantum-computing-usecases"
    },
    {
      "id": "ARCH-001",
      "date": "2026-01-25",
      "category": "company-architecture",
      "title": "Agent Memory System: File-based JSON",
      "decision": "Agent experiences stored as JSON files in .claude/memory/agent-experiences/. Company knowledge in company-knowledge.json. No database.",
      "rationale": "Agents read files, not databases. JSON is human-readable for debugging. Git tracks changes. Simple enough for all agents to interact with without tooling.",
      "alternatives_considered": ["SQLite database", "Redis for agent state", "Vector database for similarity search"],
      "outcome": "File-based system working well. Pre-filtering reduces context injection overhead.",
      "applies_to": "all-products"
    },
    {
      "id": "ARCH-002",
      "date": "2026-02-05",
      "category": "company-architecture",
      "title": "Spec-Kit Integration: GitHub spec-kit Methodology",
      "decision": "Adopt GitHub spec-kit methodology with custom 10-article constitution. Commands: specify, clarify, plan, tasks, analyze, checklist, implement.",
      "rationale": "Provides structured pipeline from CEO brief to implementation. Replaces ad-hoc process. spec-kit analyze provides automatic consistency checking.",
      "alternatives_considered": ["Custom spec format only", "JIRA-style ticket system", "Lightweight PRD only"],
      "outcome": "Full spec-kit pipeline operational. Constitution governs all work. Quality gates automated.",
      "applies_to": "all-products"
    },
    {
      "id": "ARCH-003",
      "date": "2026-02-10",
      "category": "company-architecture",
      "title": "CI/CD: GitHub Actions per Product",
      "decision": "Each product gets its own GitHub Actions workflow file. Path filters trigger only relevant product CI on PRs.",
      "rationale": "Monorepo needs per-product CI to avoid running all tests on every change. Path filters in on.pull_request.paths provide clean separation.",
      "alternatives_considered": ["Single unified workflow", "Nx for build orchestration", "Turborepo"],
      "outcome": "Per-product workflows. SAST and dependabot at repo level. Efficient CI run times.",
      "applies_to": "all-products"
    },
    {
      "id": "ARCH-004",
      "date": "2026-02-15",
      "category": "company-architecture",
      "title": "Shared Packages: Monorepo without Nx/Turborepo",
      "decision": "Shared code in /packages/* directory. No build orchestration tool (Nx, Turborepo). Products import directly from source.",
      "rationale": "Build orchestration adds complexity for current team size. Direct source imports work well with TypeScript path aliases. Simpler = less to maintain.",
      "alternatives_considered": ["Nx monorepo", "Turborepo", "NPM workspaces with published packages"],
      "outcome": "8 shared packages across auth, billing, notifications, audit, webhooks, shared, ui, saas-kit.",
      "applies_to": "all-products"
    }
  ]
}
